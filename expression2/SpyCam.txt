#
# IMPORTANT: DO NOT REMOVE OR MODIFY THIS HEADER!
#
# CREDITS / CONTRIBUTORS:
#   Originally created/developed and maintained by STEAM_0:0:65979910 (http://steamcommunity.com/profiles/76561198092225548/ - STEAM_0:0:65979910; U:1:131959820); TheCaptainPrice a.k.a. CaptainPRICE.
#
# LICENSE:
#   GNU General Public License version 3.
#
# SETUP / INSTALLATION INSTRUCTIONS:
#   Save this text file to GarrysMod/garrysmod/data/expression2 folder.
#   Requires Wire and Unofficial Wire Extras (UWSVN) addons to be installed; otherwise this won't work.
#   Spawn this E2 code, then spawn a render target (RT) camera (from Wire - Extras). Using Wire Advanced tool, wire "Camera [ENTITY]" input from Expression 2 to RT camera's "Create Entity [ENTITY]" (entity) output.
#   By default (when spawned), it will target/spy on You. To change the target player, open chatbox and say "spy X" (without double-quotes, case-insensitive), where X is optional argument/parameter that takes either player Steam ID or nick/name. To get list of Steam IDs (of all players on the current server), open (Developer) Console (make sure you have enabled it in Options first) and submit "status" command.
#   If you do not specify a valid player Steam ID nor nick/name to "spy" chat-command, it will make an additional check if you are aiming on a valid player (if you are aiming on a vehicle, it will get the driver), if valid target was found it will spy on that player and notify you about it; otherwise you will get an error message describing what went wrong (it is user-friendly).
#
#  Forum thread URL: http://www.wiremod.com/forum/finished-contraptions/35243-spycam-e2-first-public-e2-release.html
#  Repository URL: https://github.com/CaptainPRICE/Wire-Data
#  Contributions/forks are welcome, looking for tweaks/optimizations!
#  There are a few known bugs which can not be fixed using Expression 2.
#  This E2 uses object-oriented programming style. Personally I think this is one decent E2 for beginners to learn from.
#  I hope everybody will enjoy and also learn something new from this E2! :)
#  Happy spying, CaptainPRICE.
#  P.S. I have integrated auto-updater, so you don't have to check for updates manually!
#

@name SpyCam
@inputs Camera:entity
@persist Version:array Screen:entity [INVALID_VERSION_NUMBER MAJOR_AVAILABLE MINOR_AVAILABLE NO_UPDATE_AVAILABLE PATCH_AVAILABLE SPY_INVALID_TARGET SPY_NEW_TARGET SPY_SAME_TARGET] [ServerFileURL Steam2IdentifierPattern VersionFilePath VersionPattern VersionTextFileURL]:string CameraWL:wirelink
@outputs Target:entity VersionString:string

if ( first() )
{
    # Constant definitions.
    Version = array( 3, 0, 1 ) # Force upgrade by assigning Version to array(1,0,0).
    VersionPattern = "^(%d+)%.(%d+)%.(%d+)$"
    VersionString = Version:concat( "." )
    VersionFilePath = "updates/spycam/version.txt"
    VersionTextFileURL = "https://raw.githubusercontent.com/CaptainPRICE/Wire-Data/master/e2files/updates/spycam/version.txt"
    ServerFileURL = "https://raw.githubusercontent.com/CaptainPRICE/Wire-Data/master/expression2/SpyCam.txt"
    Steam2IdentifierPattern = "^STEAM_0:[0|1]:[0-9]+$"
    MAJOR_AVAILABLE = 3
    MINOR_AVAILABLE = 2
    PATCH_AVAILABLE = 1
    NO_UPDATE_AVAILABLE = 0
    INVALID_VERSION_NUMBER = -1
    SPY_INVALID_TARGET = -1
    SPY_SAME_TARGET = 0
    SPY_NEW_TARGET = 1

#ifndef propCanCreate() | propSpawnEffect( number ) | propSpawnUndo( number ) | propSpawn( string, vector, angle, number ) | entity:parentTo( entity ) | entity:propDelete() | entity:propFreeze( number ) | entity:propNotSolid( number ) | entity:setAng( angle ) | entity:setColor( vector4 ) | entity:setPos( vector )
    error( "SpyCam: Can not continue due propcore extension is not installed/enabled on this server." )
#endif

    #
    # Compares local version with server version number (format is "MAJOR.MINOR.PATCH").
    # Returns INVALID_VERSION_NUMBER when called with invalid arguments or when local major/minor/patch is greater than server major/minor/patch.
    # Returns MAJOR_AVAILABLE when local major < server major. Returns MINOR_AVAILABLE when local minor < server minor. Returns PATCH_AVAILABLE when local patch < server patch.
    #
    function number compareVersion( Local:string, Server:string )
    {
        local LocalVersion = Local:match( VersionPattern )
        local ServerVersion = Server:match( VersionPattern )
        if ( LocalVersion:count() != 3 | ServerVersion:count() != 3 )
        {
            # Received invalid input.
            return INVALID_VERSION_NUMBER
        }
        local LocalMajor = LocalVersion[ 1, string ]:toNumber()
        local ServerMajor = ServerVersion[ 1, string ]:toNumber()
        if ( LocalMajor < ServerMajor )
        {
            # Major version differs.
            return MAJOR_AVAILABLE
        }
        if ( LocalMajor > ServerMajor )
        {
            # Local major should not go above server major.
            return INVALID_VERSION_NUMBER
        }
        # Major is up-to-date. Check minor number.
        local LocalMinor = LocalVersion[ 2, string ]:toNumber()
        local ServerMinor = ServerVersion[ 2, string ]:toNumber()
        if ( LocalMinor < ServerMinor )
        {
            # Minor version differs.
            return MINOR_AVAILABLE
        }
        if ( LocalMinor > ServerMinor )
        {
            # Local minor should not go above server minor.
            return INVALID_VERSION_NUMBER
        }
        local LocalPatch = LocalVersion[ 3, string ]:toNumber()
        local ServerPatch = ServerVersion[ 3, string ]:toNumber()
        # Major and minor are up-to-date. Check patch number.
        if ( LocalPatch < ServerPatch )
        {
            # Patch version differs.
            return PATCH_AVAILABLE
        }
        if ( LocalPatch > ServerPatch )
        {
            # Local patch should not go above server patch.
            return INVALID_VERSION_NUMBER
        }
        # Local is up-to-date with server.
        return NO_UPDATE_AVAILABLE
    }

    #
    # Fetches a new update.
    #
    function fetchNewUpdate( ResponseCode:number )
    {
        local UpdateMessage = ""
        switch ( ResponseCode )
        {
            case MAJOR_AVAILABLE,
                UpdateMessage = format( "SpyCam v%s: New major update is available for download!", VersionString )
                break
            case MINOR_AVAILABLE,
                UpdateMessage = format( "SpyCam v%s: New minor update is available for download!", VersionString )
                break
            case PATCH_AVAILABLE,
                UpdateMessage = format( "SpyCam v%s: New patch update is available for download!", VersionString )
                break
            case NO_UPDATE_AVAILABLE,
                UpdateMessage = format( "SpyCam v%s: No newer updates available, you are running the most recent SpyCam :)", VersionString )
                break
            case INVALID_VERSION_NUMBER,
                error( "SpyCam: Running on invalid version number (local version is out-of-sync)!" )
                break
            default,
                error( format( "SpyCam v%s: Unhandled response code in fetchNewUpdate function (code=%s)!", VersionString, ResponseCode ) )
                break
        }
        hint( UpdateMessage, 7 )
        print( UpdateMessage )
        if ( ResponseCode != NO_UPDATE_AVAILABLE )
        {
            timer( "downloadnewupdate", httpCanRequest() ? 10 : 3000 )
        }
    }

    #
    # Checks if supplied string is valid Steam2 identifier (STEAM_0).
    #
    function number isValidSteamId( SteamId:string )
    {
        return SteamId:match( Steam2IdentifierPattern ):count() == 1
    }

    #
    # Attempts to find a player with supplied Steam ID string.
    #
    function entity findPlayerBySteamId( SteamId:string )
    {
        SteamId = SteamId:upper()
        if ( !isValidSteamId( SteamId ) )
        {
            return noentity()
        }
        foreach ( K, Player:entity = players() )
        {
            if ( Player:steamID() == SteamId )
            {
                return Player
            }
        }
        return noentity()
    }

    #
    # Attempts to find a player by (partial) name.
    #
    function entity findPlayerByPartialName( Name:string )
    {
        return findPlayerByName( Name )
    }

    #
    # Returns 1 when Camera input is wired to a valid RT camera entity/object; otherwise 0.
    #
    function number isCameraValid()
    {
        return ->Camera & Camera:isValid() & Camera:type() == "gmod_wire_rtcam"
    }

    #
    # Attempts to set the new target player to spy on.
    #
    function number trySetTarget( NewTarget:entity )
    {
        if ( !NewTarget:isValid() )
        {
            return SPY_INVALID_TARGET
        }
        if ( NewTarget:isVehicle() )
        {
            return trySetTarget( NewTarget:driver() )
        }
        if ( !NewTarget:isPlayer() )
        {
            return SPY_INVALID_TARGET
        }
        if ( NewTarget == Target )
        {
            return SPY_SAME_TARGET
        }
        Target = NewTarget
        return SPY_NEW_TARGET
    }

    #
    # Event handler that runs whenever the target is changed.
    #
    function onNewTargetEventHandler()
    {
        print( format( "SpyCam v%s: Now spying on (%s) %s.", VersionString, Target:steamID(), Target:name() ) )
        soundPlay( "newtargetsound", soundDuration( "Buttons.snd19" ), "Buttons.snd19" )
    }

    #
    # Callback function for "spy" chat-command that runs after trySetTarget function (used to announce the new target).
    #
    function announceSetTarget( ReturnCode:number )
    {
        switch ( ReturnCode )
        {
            case SPY_INVALID_TARGET,
                print( format( "SpyCam v%s: Invalid syntax provided/Could not find a valid target (correct syntax: 'spy <player Steam ID>' or aim on player and say 'spy' to spy on that player).", VersionString ) )
                soundPlay( "invalidsyntaxsound", soundDuration( "Buttons.snd10" ), "Buttons.snd10" )
                break
            case SPY_SAME_TARGET,
                print( format( "SpyCam v%s: Already spying on (%s) %s.", VersionString, Target:steamID(), Target:name() ) )
                soundPlay( "alreadyspyingsound", soundDuration( "Buttons.snd2" ), "Buttons.snd2" )
                break
            case SPY_NEW_TARGET,
                onNewTargetEventHandler()
                break
            default,
                error( format( "SpyCam v%s: Unsupported return code passed to announceSetTarget function (code=%s)!", VersionString, ReturnCode ) )
                break
        }
    }

    #
    # Returns the current time (in HH:MM:SS format).
    #
    function string timeNow( TwelveHour:number )
    {
        local Hour = ( ( time( "hour" ) + time( "isdst" ) ) % ( TwelveHour ? 12 : 24 ) ):toString()
        if ( Hour:length() < 2 )
        {
            Hour = "0" + Hour
        }
        local Min = ( time( "min" ) % 60 ):toString()
        if ( Min:length() < 2 )
        {
            Min = "0" + Min
        }
        local Sec = ( time( "sec" ) % 60 ):toString()
        if ( Sec:length() < 2 )
        {
            Sec = "0" + Sec
        }
        return format( "%s:%s:%s", Hour, Min, Sec )
    }

    runOnFile( 1 )
    runOnHTTP( 1 )
    if ( !fileCanLoad() | !httpCanRequest() | !propCanCreate() )
    {
        reset()
        exit()
    }
    fileLoad( VersionFilePath )
    httpRequest( VersionTextFileURL )

    if ( convarnum( "wire_expression2_concmd" ) )
    {
        # Requires concmd enabled:
        #  Automatically switch to RT camera tool when this E2 gets spawned (simply to save time).
        concmd( "gmod_toolmode wire_rtcam" )
    }
    propSpawnEffect( 0 )
    propSpawnUndo( 0 )
    local Ang = entity():angles()
    Ang = angnorm( ang( Ang:pitch() - 90, Ang:yaw(), Ang:roll() ) )
    Screen = propSpawn( "models/props_phx/rt_screen.mdl", entity():pos() + ( entity():forward() * vec( 23.5 ) ), Ang, 1 )
    if ( !Screen:isValid() )
    {
        error( "SpyCam: Can not continue due RT screen failed to spawn." )
    }
    Screen:parentTo( entity() )
    Screen:propNotSolid( 1 )
    Target = owner() # Default target to spy on.

    runOnChat( 1 )
    runOnLast( 1 )
    runOnTick( 1 )
}
elseif ( chatClk( owner() ) )
{
    local Trim = owner():lastSaid():trim()
    local Exploded = Trim:explode( " " )
    switch ( Exploded[ 1, string ]:lower() )
    {
        case "spy",
            hideChat( 1 )
            Exploded:removeString( 1 )
            Trim = Exploded:concat( " " ):trim()
            local ReturnCode = SPY_INVALID_TARGET
            if ( Trim:length() > 1 )
            {
                # Optional argument is not empty. Check input against Steam2 ID.
                ReturnCode = trySetTarget( findPlayerBySteamId( Trim ) )
                if ( ReturnCode == SPY_INVALID_TARGET )
                {
                    # Input is not a valid Steam2 ID? Find a player by (partial) nick/name.
                    ReturnCode = trySetTarget( findPlayerByPartialName( Trim ) )
                }
            }
            if ( ReturnCode == SPY_INVALID_TARGET )
            {
                # Still invalid target? Check aim entity.
                ReturnCode = trySetTarget( owner():aimEntity() )
            }
            announceSetTarget( ReturnCode ) # Run the callback function.
            break
    }
}
elseif ( fileClk( VersionFilePath ) )
{
    local FileStatus = fileStatus()
    switch ( FileStatus )
    {
        case _FILE_404,
            if ( !fileCanWrite() )
            {
                print( format( "SpyCam v%s: Could not write a version file!", VersionString ) )
                break
            }
            fileWrite( VersionFilePath, VersionString )
            break
        case _FILE_OK,
            local ReadVersion = fileRead():match( VersionPattern )
            local ReadVersionString = ReadVersion:concat( "." )
            local ResponseCode = compareVersion( ReadVersionString, VersionString )
            switch ( ResponseCode )
            {
                case MAJOR_AVAILABLE,
                case MINOR_AVAILABLE,
                case PATCH_AVAILABLE,
                    print( format( "SpyCam v%s: Successfully upgraded to v%s!", ReadVersionString, VersionString ) )
                    break
                case NO_UPDATE_AVAILABLE,
                    break
                case INVALID_VERSION_NUMBER,
                    error( "SpyCam: Invalid version number returned from compareVersion function!" )
                    break
                default,
                    error( format( "SpyCam v%s: Unhandled response returned from compareVersion function (code=%s)!", VersionString, ResponseCode ) )
                    break
            }
            if ( !fileCanWrite() )
            {
                print( format( "SpyCam v%s: Could not write a version file!", VersionString ) )
                break
            }
            fileWrite( VersionFilePath, VersionString )
            break
        default,
            print( format( "SpyCam v%s: Something went wrong on version file access (file status=%s)!", VersionString, FileStatus ) )
            break
    }
}
elseif ( httpClk() & httpRequestUrl() == VersionTextFileURL )
{
    fetchNewUpdate( compareVersion( VersionString, httpData():match( VersionPattern ):concat( "." ) ) )
    exit()
}
elseif ( clk( "downloadnewupdate" ) )
{
    # Repeat until a HTTP request can be send.
    if ( !httpCanRequest() )
    {
        timer( clkName(), 100 )
        exit()
    }
    # Get contents of the most recent Expression 2 text file.
    httpRequest( ServerFileURL )
    stoptimer( clkName() )
}
elseif ( httpClk() & httpRequestUrl() == ServerFileURL )
{
    timer( "installnewupdate", fileCanWrite() ? 10 : 200 )
}
elseif ( clk( "installnewupdate" ) )
{
    local NewExpression2Code = httpData()
#ifdef entity:remoteSetCode( string )
    entity():remoteSetCode( NewExpression2Code )
#else
    # Repeat until a file can be written to disk.
    if ( !fileCanWrite() )
    {
        timer( clkName(), 100 )
        exit()
    }
    fileWrite( ">e2shared/spycam.txt", NewExpression2Code )
    print( format( "SpyCam v%s: New update has been downloaded to e2shared/spycam.txt file!", VersionString ) )
#endif
    stoptimer( clkName() )
}
elseif ( last() )
{
    if ( isCameraValid() )
    {
        Camera:propDelete()
    }
    exit()
}
if ( !isCameraValid() )
{
    setName( format( "SpyCam (version %s)\nTime now : %s", VersionString, timeNow( 0 ) ) )
    exit()
}
if ( changed( Camera ) )
{
    Camera:propFreeze( 1 )
    Camera:propNotSolid( 1 )
    Camera:setColor( vec4( 255, 255, 255, 0 ) )
    CameraWL = Camera:wirelink()
    CameraWL[ "Activate", number ] = 1
}
if ( !Target:isValid() | !Target:isPlayer() )
{
    trySetTarget( owner() ) # The target player have disconnected? Fallback target.
}
setName( format( "SpyCam (version %s)\nSpying on (%s) %s\nTime now : %s", VersionString, Target:steamID(), Target:name(), timeNow( 0 ) ) )
if ( !Target:isAlive() ) # It would be invalid to compare the target player health, because it is possible to have negative (< 0) HP while a player is alive (engine bug).
{
    exit()
}
Camera:setAng( Target:eyeAngles() )
Camera:setPos( ( Target:inVehicle() & Target:vehicle():isValid() & Target:vehicle():isVehicle() ) ? Target:vehicle():attachmentPos( "vehicle_driver_eyes" ) : Target:attachmentPos( "eyes" ) )
