#
# IMPORTANT: DO NOT REMOVE OR MODIFY THIS HEADER!
#
# CREDITS / CONTRIBUTORS:
#   Originally created/developed and maintained by STEAM_0:0:65979910 (http://steamcommunity.com/profiles/76561198092225548/ - STEAM_0:0:65979910; U:1:131959820); TheCaptainPrice a.k.a. CaptainPRICE.
#
# LICENSE:
#   GNU General Public License version 3.
#
# SETUP / INSTALLATION INSTRUCTIONS:
#   Save this text file to GarrysMod/garrysmod/data/expression2 folder.
#   Requires Wire and Unofficial Wire Extras (UWSVN) addons to be installed; otherwise this won't work.
#   Spawn this E2 code, then spawn a render target (RT) camera (from Wire - Extras). Using Wire Advanced tool, wire "Camera [ENTITY]" input from Expression 2 to RT camera's "Create Entity [ENTITY]" (entity) output.
#   By default, it will target/spy on You. To change the target player, open chatbox and say "spy X" (without double-quotes), where X is optional argument/parameter that takes Steam ID. To get Steam ID of player, open (Developer) Console (make sure you have enabled it in Options first) and submit "status" command.
#   If you do not specify a player's Steam ID to "spy" chat-command, it will make an additional check if you are aiming on a valid player, if so it will target that player; otherwise you will get an error message describing what went wrong - it is user-friendly.
#
#  Forum thread URL: http://www.wiremod.com/forum/finished-contraptions/35243-spycam-e2-first-public-e2-release.html
#  Repository URL: https://github.com/CaptainPRICE/Wire-Data
#  Contributions/forks are welcome, looking for tweaks/optimizations!
#  There are a few known bugs which can not be fixed using Expression 2.
#  I hope everybody will enjoy and also learn something new from this E2! :)
#  Happy spying, CaptainPRICE.
#  P.S. I have integrated auto-updater, so you don't have to check for updates manually!
#

@name SpyCam
@inputs Camera:entity
@persist Version:array Screen:entity [MAJOR_AVAILABLE MINOR_AVAILABLE NO_UPDATE_AVAILABLE PATCH_AVAILABLE] [ServerFileURL VersionFilePath VersionPattern VersionTextFileURL]:string CameraWL:wirelink
@outputs Target:entity VersionString:string

if ( first() )
{
    # Constant definitions.
    Version = array( 2, 0, 0 )
    VersionPattern = "^(%d+)%.(%d+)%.(%d+)$"
    VersionString = Version:concat( "." )
    VersionFilePath = "updates/spycam/version.txt"
    VersionTextFileURL = "https://raw.githubusercontent.com/CaptainPRICE/Wire-Data/master/e2files/updates/spycam/version.txt"
    ServerFileURL = "https://raw.githubusercontent.com/CaptainPRICE/Wire-Data/master/expression2/SpyCam.txt"
    MAJOR_AVAILABLE = 3
    MINOR_AVAILABLE = 2
    PATCH_AVAILABLE = 1
    NO_UPDATE_AVAILABLE = 0

#ifndef propSpawnEffect( number ) | propSpawnUndo( number ) | propSpawn( string, vector, angle, number ) | entity:parentTo( entity ) | entity:propDelete() | entity:propFreeze( number ) | entity:propNotSolid( number ) | entity:setAng( angle ) | entity:setColor( vector4 ) | entity:setPos( vector )
    error( "Can not continue due propcore extension is not installed/enabled on this server." )
#endif

    #
    # Compares local version with server version.
    #
    function number compareVersion( Local:string, Server:string )
    {
        local LocalVersion = Local:match( VersionPattern )
        local ServerVersion = Server:match( VersionPattern )
        if ( LocalVersion:count() != 3 | ServerVersion:count() != 3 )
        {
            return -1 # Received invalid input.
        }
        local LocalMajor = LocalVersion[ 1, string ]:toNumber()
        local ServerMajor = ServerVersion[ 1, string ]:toNumber()
        if ( LocalMajor < ServerMajor )
        {
            return MAJOR_AVAILABLE
        }
        if ( LocalMajor >= ServerMajor )
        {
            return NO_UPDATE_AVAILABLE
        }
        local LocalMinor = LocalVersion[ 2, string ]:toNumber()
        local ServerMinor = ServerVersion[ 2, string ]:toNumber()
        if ( LocalMinor < ServerMinor )
        {
            return MINOR_AVAILABLE
        }
        if ( LocalMinor >= ServerMinor )
        {
            return NO_UPDATE_AVAILABLE
        }
        if ( LocalVersion[ 3, string ]:toNumber() < ServerVersion[ 3, string ]:toNumber() )
        {
            return PATCH_AVAILABLE
        }
        return NO_UPDATE_AVAILABLE
    }

    #
    # Fetches a new update.
    #
    function fetchNewUpdate( ResponseCode:number )
    {
        local UpdateMessage = ""
        switch ( ResponseCode )
        {
            case MAJOR_AVAILABLE,
                UpdateMessage = format( "SpyCam v%s: New major update is available for download!", VersionString )
                break
            case MINOR_AVAILABLE,
                UpdateMessage = format( "SpyCam v%s: New minor update is available for download!", VersionString )
                break
            case PATCH_AVAILABLE,
                UpdateMessage = format( "SpyCam v%s: New patch update is available for download!", VersionString )
                break
            case NO_UPDATE_AVAILABLE,
                UpdateMessage = format( "SpyCam v%s: No newer updates available, you are running the most recent SpyCam :)", VersionString )
                break
            default,
                error( format( "SpyCam v%s: Unhandled response code in fetchNewUpdate function (code=%s)!", VersionString, ResponseCode ) )
                break
        }
        hint( UpdateMessage, 7 )
        print( UpdateMessage )
        if ( ResponseCode != NO_UPDATE_AVAILABLE )
        {
            timer( "downloadnewupdate", httpCanRequest() ? 10 : 3000 )
        }
    }

    function entity findPlayerBySteamId( SteamId:string )
    {
        foreach ( K, Player:entity = players() )
        {
            if ( Player:steamID() == SteamId )
            {
                return Player
            }
        }
        return noentity()
    }

    function number trySetTarget( NewTarget:entity )
    {
        if ( !NewTarget:isValid() | !NewTarget:isPlayer() )
        {
            return 0
        }
        if ( NewTarget == Target )
        {
            return -1
        }
        Target = NewTarget
        return 1
    }

    function string timeNow()
    {
        local Hour = ( ( time( "hour" ) + time( "isdst" ) ) % 24 ):toString()
        if ( Hour:length() < 2 )
        {
            Hour = "0" + Hour
        }
        local Min = ( time( "min" ) % 60 ):toString()
        if ( Min:length() < 2 )
        {
            Min = "0" + Min
        }
        local Sec = ( time( "sec" ) % 60 ):toString()
        if ( Sec:length() < 2 )
        {
            Sec = "0" + Sec
        }
        return format( "%s:%s:%s", Hour, Min, Sec )
    }

    if ( convarnum( "wire_expression2_concmd" ) )
    {
        # Requires concmd enabled:
        #  Automatically switch to RT camera tool when this E2 gets spawned (simply to save time).
        concmd( "gmod_toolmode wire_rtcam" )
    }
    propSpawnEffect( 0 )
    propSpawnUndo( 0 )
    local Ang = entity():angles()
    Ang = angnorm( ang( Ang:pitch() - 90, Ang:yaw() + 180, Ang:roll() + 180 ) )
    Screen = propSpawn( "models/props_phx/rt_screen.mdl", entity():pos() + ( entity():forward() * vec( 23.5 ) ), Ang, 1 )
    if ( !propCanCreate() | !Screen:isValid() )
    {
        error( "Can not continue due RT screen failed to spawn." )
    }
    Screen:parentTo( entity() )
    Screen:propNotSolid( 1 )
    Target = owner() # Default target to spy on.

    runOnFile( 1 )
    runOnHTTP( 1 )
    if ( !fileCanLoad() | !httpCanRequest() )
    {
        reset()
        exit()
    }
    fileLoad( VersionFilePath )
    httpRequest( VersionTextFileURL )

    runOnChat( 1 )
    runOnLast( 1 )
    runOnTick( 1 )
}
elseif ( chatClk( owner() ) )
{
    local Trim = owner():lastSaid():trim()
    local Exploded = Trim:explode( " " )
    switch ( Exploded[ 1, string ]:lower() )
    {
        case "spy",
            hideChat( 1 )
            Exploded:removeString( 1 )
            Trim = Exploded:concat( " " )
            if ( trySetTarget( findPlayerBySteamId( Trim:trim() ) ) )
            {
                print( format( "SpyCam v%s: Now spying on (%s) %s.", VersionString, Target:steamID(), Target:name() ) )
                break
            }
            local ResultCode = trySetTarget( owner():aimEntity() )
            switch ( ResultCode )
            {
                case -1,
                    print( format( "SpyCam v%s: Already spying on (%s) %s.", VersionString, Target:steamID(), Target:name() ) )
                    break
                case 0,
                    print( format( "SpyCam v%s: Invalid syntax provided/Could not find a valid target (correct syntax: 'spy <player Steam ID>' or aim on player and say 'spy' to spy on that player).", VersionString ) )
                    break
                case 1,
                    print( format( "SpyCam v%s: Now spying on (%s) %s.", VersionString, Target:steamID(), Target:name() ) )
                    break
                default,
                    error( format( "SpyCam v%s: Unsupported result code returned from trySetTarget function (code=%s)!", VersionString, ResultCode ) )
                    break
            }
            # TODO:
            #  Detect whether an argument/parameter (first one) passed is valid Steam identifier.
            #  Implement search by player (partial) name. Note, Steam ID should have higher precedence than search by nick/name.
            #  Play sound after print.
            break
    }
}
elseif ( fileClk( VersionFilePath ) )
{
    local FileStatus = fileStatus()
    switch ( FileStatus )
    {
        case _FILE_404,
            if ( !fileCanWrite() )
            {
                print( format( "SpyCam v%s: Could not write a version file!", VersionString ) )
                break
            }
            fileWrite( VersionFilePath, VersionString )
            break
        case _FILE_OK,
            local ReadVersion = fileRead():match( VersionPattern )
            local ReadVersionString = ReadVersion:concat( "." )
            local ResponseCode = compareVersion( ReadVersionString, VersionString )
            switch ( ResponseCode )
            {
                case MAJOR_AVAILABLE,
                case MINOR_AVAILABLE,
                case PATCH_AVAILABLE,
                    print( format( "SpyCam v%s: Successfully upgraded to v%s!", ReadVersionString, VersionString ) )
                    break
                case NO_UPDATE_AVAILABLE,
                    break
                default,
                    error( format( "SpyCam v%s: Unhandled response returned from compareVersion function (code=%s)!", VersionString, ResponseCode ) )
                    break
            }
            if ( !fileCanWrite() )
            {
                print( format( "SpyCam v%s: Could not write a version file!", VersionString ) )
                break
            }
            fileWrite( VersionFilePath, VersionString )
            break
        default,
            print( format( "SpyCam v%s: Something went wrong on version file access (file status=%s)!", VersionString, FileStatus ) )
            break
    }
}
elseif ( httpClk() & httpRequestUrl() == VersionTextFileURL )
{
    fetchNewUpdate( compareVersion( VersionString, httpData():match( VersionPattern ):concat( "." ) ) )
    exit()
}
elseif ( clk( "downloadnewupdate" ) )
{
    # Repeat until a HTTP request can be send.
    if ( !httpCanRequest() )
    {
        timer( clkName(), 100 )
        exit()
    }
    # Get contents of the most recent Expression 2 text file.
    httpRequest( ServerFileURL )
    stoptimer( clkName() )
}
elseif ( httpClk() & httpRequestUrl() == ServerFileURL )
{
    timer( "installnewupdate", fileCanWrite() ? 10 : 200 )
}
elseif ( clk( "installnewupdate" ) )
{
    local NewExpression2Code = httpData()
#ifdef entity:remoteSetCode( string )
    entity():remoteSetCode( NewExpression2Code )
#else
    # Repeat until a file can be written to disk.
    if ( !fileCanWrite() )
    {
        timer( clkName(), 100 )
        exit()
    }
    fileWrite( ">e2shared/spycam.txt", NewExpression2Code )
    print( format( "SpyCam v%s: New update has been downloaded to e2shared/spycam.txt file!", VersionString ) )
#endif
    stoptimer( clkName() )
}
elseif ( last() )
{
    if ( ->Camera & Camera:isValid() & Camera:type() == "gmod_wire_rtcam" )
    {
        Camera:propDelete()
    }
    exit()
}
if ( !->Camera | !Camera:isValid() | Camera:type() != "gmod_wire_rtcam" )
{
    setName( format( "SpyCam (version %s)\nTime now : %s", VersionString, timeNow() ) )
    exit()
}
if ( changed( Camera ) )
{
    Camera:propFreeze( 1 )
    Camera:propNotSolid( 1 )
    Camera:setColor( vec4( 255, 255, 255, 0 ) )
    CameraWL = Camera:wirelink()
    CameraWL[ "Activate", number ] = 1
}
if ( !Target:isValid() | !Target:isPlayer() )
{
    trySetTarget( owner() ) # The target player have disconnected? Fallback target.
}
setName( format( "SpyCam (version %s)\nSpying on (%s) %s\nTime now : %s", VersionString, Target:steamID(), Target:name(), timeNow() ) )
if ( !Target:isAlive() ) # It would be invalid to compare the target player health, because it is possible to have negative (< 0) HP while a player is alive (engine bug).
{
    exit()
}
Camera:setAng( Target:eyeAngles() )
Camera:setPos( ( Target:inVehicle() & Target:vehicle():isValid() & Target:vehicle():isVehicle() ) ? Target:vehicle():attachmentPos( "vehicle_driver_eyes" ) : Target:attachmentPos( "eyes" ) )
