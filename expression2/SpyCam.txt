#
# IMPORTANT: DO NOT REMOVE OR MODIFY THIS HEADER!
#
# CREDITS / CONTRIBUTORS:
#   Originally created/developed and maintained by STEAM_0:0:65979910 (http://steamcommunity.com/profiles/76561198092225548/ - STEAM_0:0:65979910; U:1:131959820); TheCaptainPrice a.k.a. CaptainPRICE.
#
# LICENSE:
#   GNU General Public License version 3.
#
# SETUP / INSTALLATION INSTRUCTIONS:
#   Save this text file to GarrysMod/garrysmod/data/expression2 folder.
#   Requires Wire and Unofficial Wire Extras (UWSVN) addons to be installed; otherwise this won't work.
#   Spawn this E2 code, then spawn a render target (RT) camera (from Wire - Extras). Using Wire Advanced tool, wire "Camera [ENTITY]" input from Expression 2 to RT camera's "Create Entity [ENTITY]" (entity) output.
#   By default, it will target/spy on You. To change the target player, open chatbox and say "spy X" (without double-quotes), where X is optional argument/parameter that takes Steam ID. To get Steam ID of player, open (Developer) Console (make sure you have enabled it in Options first) and submit "status" command.
#   If you do not specify a player's Steam ID to "spy" chat-command, it will make an additional check if you are aiming on a valid player, if so it will target that player; otherwise you will get an error message describing what went wrong - it is user-friendly.
#
#  Contributions/forks are welcome, looking for tweaks/optimizations!
#  There are a few known bugs which can not be fixed using Expression 2.
#  I hope everybody will enjoy and also learn something new from this E2! :)
#  Happy spying, CaptainPRICE.
#  P.S. I have integrated auto-updater, so you don't have to check for updates manually!
#

@name SpyCam
@inputs Camera:entity
@persist Screen:entity CameraWL:wirelink
@outputs Version:array Target:entity [ServerFileURL VersionFilePath VersionString VersionTextFileURL]:string

if ( first() )
{
    Version = array( 1, 1, 2 )
    VersionString = Version:concat( "." )
    VersionFilePath = "updates/spycam/version.txt"
    VersionTextFileURL = "https://raw.githubusercontent.com/CaptainPRICE/Wire-Data/master/e2files/updates/spycam/version.txt"
    ServerFileURL = "https://raw.githubusercontent.com/CaptainPRICE/Wire-Data/master/expression2/SpyCam.txt"
#ifndef propSpawnEffect( number ) | propSpawnUndo( number ) | propSpawn( string, vector, angle, number ) | entity:parentTo( entity ) | entity:propDelete() | entity:propFreeze( number ) | entity:propNotSolid( number ) | entity:setAng( angle ) | entity:setColor( vector4 ) | entity:setPos( vector )
    error( "Can not continue due propcore extension is not installed/enabled on this server." )
#endif

    function entity findPlayerBySteamId( SteamId:string )
    {
        foreach ( K, Player:entity = players() )
        {
            if ( Player:steamID() == SteamId )
            {
                return Player
            }
        }
        return noentity()
    }

    function number trySetTarget( NewTarget:entity )
    {
        if ( !NewTarget:isValid() | !NewTarget:isPlayer() )
        {
            return 0
        }
        if ( NewTarget == Target )
        {
            return -1
        }
        Target = NewTarget
        return 1
    }

    if ( convarnum( "wire_expression2_concmd" ) )
    {
        # Requires concmd enabled:
        #  Automatically switch to RT camera tool when this E2 gets spawned (simply to save time).
        concmd( "gmod_toolmode wire_rtcam" )
    }
    setName( format( "SpyCam (version %s)", VersionString ) )
    propSpawnEffect( 0 )
    propSpawnUndo( 0 )
    local Ang = entity():angles()
    Ang = angnorm( ang( Ang:pitch() - 90, Ang:yaw() + 180, Ang:roll() + 180 ) )
    Screen = propSpawn( "models/props_phx/rt_screen.mdl", entity():pos() + ( entity():forward() * vec( 23.5 ) ), Ang, 1 )
    if ( !propCanCreate() | !Screen:isValid() )
    {
        error( "Can not continue due RT screen failed to spawn." )
    }
    Screen:parentTo( entity() )
    Screen:propNotSolid( 1 )
    Target = owner() # Default target to spy on.

    runOnFile( 1 )
    runOnHTTP( 1 )
    if ( !fileCanLoad() | !httpCanRequest() )
    {
        reset()
        exit()
    }
    fileLoad( VersionFilePath )
    httpRequest( VersionTextFileURL )

    runOnChat( 1 )
    runOnLast( 1 )
    runOnTick( 1 )
}
elseif ( chatClk( owner() ) )
{
    local Trim = owner():lastSaid():trim()
    local Exploded = Trim:explode( " " )
    switch ( Exploded[ 1, string ]:lower() )
    {
        case "spy",
            hideChat( 1 )
            Exploded:removeString( 1 )
            Trim = Exploded:concat( " " )
            if ( trySetTarget( findPlayerBySteamId( Trim:trim() ) ) )
            {
                print( format( "%s: Now spying on (%s) '%s'.", entity():getName(), Target:steamID(), Target:name() ) )
                break
            }
            local ResultCode = trySetTarget( owner():aimEntity() )
            if ( ResultCode == -1 )
            {
                print( format( "%s: Already spying on (%s) '%s'.", entity():getName(), Target:steamID(), Target:name() ) )
            }
            elseif ( ResultCode == 0 )
            {
                print( format( "%s: Invalid syntax provided/Could not find a valid target (correct syntax: 'spy <player Steam ID>' or aim on player and say 'spy' to spy on that player).", entity():getName() ) )
            }
            elseif ( ResultCode == 1 )
            {
                print( format( "%s: Now spying on (%s) '%s'.", entity():getName(), Target:steamID(), Target:name() ) )
            }
            # TODO:
            #  Detect whether an argument/parameter (first one) passed is valid Steam identifier.
            #  Implement search by player (partial) name. Notice, Steam ID should have higher precedence than search by nick/name.
            #  Play sound after print.
            break
    }
}
elseif ( fileClk( VersionFilePath ) )
{
    local FileStatus = fileStatus()
    switch ( FileStatus )
    {
        case _FILE_404,
            if ( !fileCanWrite() )
            {
                print( format( "%s: Could not write a version file!", entity():getName() ) )
                break
            }
            fileWrite( VersionFilePath, VersionString )
            break
        case _FILE_OK,
            local ReadVersion = fileRead():gmatch( "(%d+)%.(%d+)%.(%d+)" )[ 1, array ]
            if ( Version[ 1, number ] > ReadVersion[ 1, string ]:toNumber() | Version[ 2, number ] > ReadVersion[ 2, string ]:toNumber() | Version[ 3, number ] > ReadVersion[ 3, string ]:toNumber() )
            {
                print( format( "%s: Successfully upgraded to v%s!", entity():getName(), VersionString ) )
            }
            if ( !fileCanWrite() )
            {
                print( format( "%s: Could not write a version file!", entity():getName() ) )
                break
            }
            fileWrite( VersionFilePath, VersionString )
            break
        default,
            print( format( "%s: Something went wrong on version file access (file status=%s)!", entity():getName(), FileStatus ) )
            break
    }
}
elseif ( httpClk() & httpRequestUrl() == VersionTextFileURL )
{
    # Compare current version with server response version.
    local ReadVersion = httpData():gmatch( "(%d+)%.(%d+)%.(%d+)" )[ 1, array ]
    if ( Version[ 1, number ] >= ReadVersion[ 1, string ]:toNumber() & Version[ 2, number ] >= ReadVersion[ 2, string ]:toNumber() & Version[ 3, number ] >= ReadVersion[ 3, string ]:toNumber() )
    {
        print( format( "%s: No updates available, you are running the most recent SpyCam :)", entity():getName() ) )
        exit()
    }
    # Fetch a new update.
    timer( "downloadnewupdate", httpCanRequest() ? 10 : 3000 )
    local UpdateMessage = format( "%s: New update is available for download!", entity():getName(), VersionString )
    hint( UpdateMessage, 7 )
    print( UpdateMessage )
}
elseif ( clk( "downloadnewupdate" ) )
{
    # Repeat until a HTTP request can be send.
    if ( !httpCanRequest() )
    {
        timer( clkName(), 100 )
        exit()
    }
    # Get contents of the most recent Expression 2 text file.
    httpRequest( ServerFileURL )
    stoptimer( clkName() )
}
elseif ( httpClk() & httpRequestUrl() == ServerFileURL )
{
    timer( "installnewupdate", fileCanWrite() ? 10 : 200 )
}
elseif ( clk( "installnewupdate" ) )
{
    local NewExpression2Code = httpData()
#ifdef entity:remoteSetCode( string )
    entity():remoteSetCode( NewExpression2Code )
#else
    # Repeat until a file can be written to disk.
    if ( !fileCanWrite() )
    {
        timer( clkName(), 100 )
        exit()
    }
    fileWrite( ">e2shared/spycam.txt", NewExpression2Code )
    print( format( "%s: New update has been downloaded to e2shared/spycam.txt file!", entity():getName() ) )
#endif
    stoptimer( clkName() )
}
elseif ( last() )
{
    if ( ->Camera & Camera:isValid() & Camera:type() == "gmod_wire_rtcam" )
    {
        Camera:propDelete()
    }
    exit()
}
if ( !->Camera | !Camera:isValid() | Camera:type() != "gmod_wire_rtcam" | !Target:isValid() | !Target:isPlayer() | !Target:isAlive() )
{
    exit()
}
if ( changed( Camera ) )
{
    Camera:propFreeze( 1 )
    Camera:propNotSolid( 1 )
    Camera:setColor( vec4( 255, 255, 255, 0 ) )
    CameraWL = Camera:wirelink()
    CameraWL[ "Activate", number ] = 1
}
Camera:setAng( Target:eyeAngles() )
Camera:setPos( ( Target:inVehicle() & Target:vehicle():isValid() & Target:vehicle():isVehicle() ) ? Target:vehicle():attachmentPos( "vehicle_driver_eyes" ) : Target:attachmentPos( "eyes" ) )
